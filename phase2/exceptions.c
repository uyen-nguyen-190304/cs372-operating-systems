/******************************* EXCEPTIONS.c ***************************************
 * 
 * This module implements the exception handling routines for the Pandos kernel.
 * It is responsible for handling a variety of exceptions generated by the UMPS3 
 * hardware: system calls, TLB faults, and program traps. When an exception occurs,
 * the processor’s state is saved in the BIOS data page. Based on the exception code 
 * extracted from the Cause register, the general exception handler dispatches control 
 * to one of the specific handlers: for interrupts, it calls the device interrupt 
 * handler; for TLB exceptions (codes 1–3) it invokes the TLBExceptionHandler; for 
 * system calls (code 8) it calls syscallExceptionHandler; and for all other cases 
 * (program traps) it calls programTrapExceptionHandler. For system calls, the module 
 * further dispatches to routines such as createProcess, terminateProcess, passeren, 
 * verhogen, waitForIODevice, getCPUTime, waitForClock, and getSupportData. When a 
 * process has installed a support structure, the “pass up or die” mechanism is used 
 * to either transfer control to a user-level exception handler or terminate the process 
 * if no handler is available. Additionally, CPU time is accounted for via external 
 * global variables. Overall, this module is central to ensuring that exceptions are 
 * handled robustly and consistently across the system.
 * 
 * Written by  : Uyen Nguyen
 * Last update : 2025/02/28 
 * 
 ***********************************************************************************/

#include "../h/const.h"
#include "../h/types.h"
#include "../h/pcb.h"
#include "../h/asl.h"
#include "../h/scheduler.h"
#include "../h/exceptions.h"
#include "../h/interrupts.h"
#include "../h/initial.h"
#include "/usr/include/umps3/umps/libumps.h"

/*******************************  FUNCTION DECLARATION  *******************************/ 

HIDDEN void createProcess(state_PTR initialState, support_t *supportStruct);
HIDDEN void terminateProcess(pcb_PTR proc);
HIDDEN void passeren(int *semAdd);
HIDDEN void verhogen(int *semAdd);
HIDDEN void waitForIODevice(int lineNum, int deviceNum, int readBoolean);
HIDDEN void getCPUTime();
HIDDEN void waitForClock();
HIDDEN void getSupportData();

/*******************************  FUNCTION IMPLEMENTATION  *******************************/ 
/*
 * Function     :   createProcess
 * Purpose      :   Implement the SYS1 system call to create a new process
 *                  It allocates a PCB, copies an initial processor state into the new process,
 *                  sets up its support structure (if any), links it as a child of the current 
 *                  process, and inserts it into the ready queue. If it can create a new process,
 *                  returns 0 in the calling process's v0 register. If no PCB available, returns -1.
 *                  Finally, load the processor state saved at the time the system call was executed
 * Parameters   :   initialState  - pointer to the processor state to copy for the new process
 *                  supportStruct - pointer to the support structure for handling exception (can be NULL)
 *  
 */
void createProcess(state_PTR initialState, support_t *supportStruct)
{
    /* Attempt to allocate a PCB from the pcbFree list*/
    pcb_PTR newPcb;
    newPcb = allocPcb();

    /* If there are enough resources to create a new process */
    if (newPcb != NULL) {
        /* Copy the initial processor state into the new PCB's state field */
        copyState(initialState, &(newPcb->p_s));

        /* Set the support structure pointer (or NULL if not provided) */
        newPcb->p_supportStruct = supportStruct;

        /* Link the new PCB as a child of the current process */
        insertChild(currentProcess, newPcb);

        /* Insert the new process into the ready queue */
        insertProcQ(&readyQueue, newPcb);

        /* Set the blocking semaphore pointer to NULL, since the process is not blocked */
        newPcb->p_semAdd = NULL;

        /* Initialize accumulated CPU time to zero */
        newPcb->p_time = 0;

        /* Increment the process count */
        processCount++;

        /* Return success (0) to the calling process in its v0 register */
        currentProcess->p_s.s_v0 = 0;
    }

    /* In case there are no more free pcbs */
    else {
        /* Return an error code (-1) in caller's v0 register */
        currentProcess->p_s.s_v0 = -1;
    }

    /* Load the saved processor state to resume execution at the point of the system call */
    LDST((state_PTR) BIOSDATAPAGE);
}


/*
 * Function     :   terminateProcess
 * Purpose      :   Implement the SYS2 system call to terminate a process and all of its progeny.
 *                  It head recursively termnates all children of the process. If the process is 
 *                  blocked, removes it from the ASL; otherwise, removes it from the ready queue.
 *                  Returns the PCB to the free list and decrements processCount.
 * Parameters   :   proc - pointer to the PCB of the process to terminate.
 */
void terminateProcess(pcb_PTR proc)
{
    /* Recursively terminate all progeny of proc */
    while (!(emptyChild(proc))) {
        /* While the process that will be terminated still has children */
        terminateProcess(removeChild(proc));
    }

    /* If proc has a parent, unlink it from the parent's child list */
    if (proc->p_prnt != NULL) {
        outChild(proc);
    }

    /* Determine if the proc is blocked on a semaphore or in the ready queue */
    if (proc->p_semAdd != NULL) {
        /* The proc is blocked on a semaphore */
        outBlocked(proc);       /* Remove the process from the ASL */

        /* Adjust semaphore or softBlockCount depending on semaphore type */
        if (proc->p_semAdd >= &deviceSemaphores[0] &&
            proc->p_semAdd <= &deviceSemaphores[MAXDEVICES - 1]) {
            /* If the process is blocked on a device semaphore */
            softBlockCount--;
        } else {
            /* If the process is blocked on a synchronization semaphore */
            (*proc->p_semAdd)++;
        }
    }

    /* Else, proc is on the ready queue */ 
    else {
        /* Remove it from the ready queue */
        outProcQ(&readyQueue, proc);
    }

    /* Return the PCB to the free list and update process count */
    freePcb(proc);
    processCount--;

    /* Setting the process pointer to NULL */
    proc = NULL;
}


/*
 * Function     :   passeren
 * Purpose      :   Implement the SYS3 system call (P operation) for semaphore decrement.
 *                  Decrement the semaphore. If the resulting value is less than 0, the
 *                  current process is blocked (inserted into the ASL) and the scheduler 
 *                  is invoked. Otherwise, resume by loading the saved processor state.
 * Parameters   :   semAdd - pointer to the semaphore to be decremented
 */ 
void passeren(int *semAdd) {
    /* Decrement the semaphore's value by 1 */
    (*semAdd)--;

    /* If the semaphore is less than 0, then the process will be blocked */
    if (*semAdd < 0) {
        /* Block the process by inserting it into the ASL for the given semaphore */
        insertBlocked(semAdd, currentProcess);
        
        /* Copy the saved processor state into current process's pcb */        
        copyState((state_PTR) BIOSDATAPAGE, &(currentProcess->p_s));

        /* Update the accumulated CPU time for currentProcess */
        STCK(currentTOD);
        currentProcess->p_time += (currentTOD - startTOD);

        /* Call the scheduler to dispatch another process */
        scheduler();                    /* This should never return */

        /* If the scheduler() returns, something went wrong, be PANIC */
        PANIC();
    }

    /* Resume execution at the point where the system call was made */
    LDST((state_PTR) BIOSDATAPAGE);
}   


/*
 * Function     :   verhogen
 * Purpose      :   Implements the SYS4 system call (V operation) for semaphore increment.
 *                  Increment the semaphore. If the new value is less than or equal to 0, 
 *                  a process is waiting in this semaphore. In that case, the process is 
 *                  removed from the ASL and inserted into the ready queue. Finally, resume
 *                  execution by reloading the saved processor state.
 * Parameters   :   semAdd - pointer to the semaphore to be incremented
 */
void verhogen(int *semAdd) {
    dev_tprint("verhogen: semAdd=%x, value before=%d\n", semAdd, *semAdd);

    /* Increment the semaphore's value by 1 */
    (*semAdd)++;

    /* If the new value is less than or equal to 0, then one or more processes are waiting */
    if (*semAdd <= 0) {
        /* Remove the first blocked process from the semaphore's queue */
        pcb_PTR unblockedProc;
        unblockedProc = removeBlocked(semAdd);      

        /* Insert the unblocked process into the ready queue */
        insertProcQ(&readyQueue, unblockedProc);
    }

    /* Resume execution at the point where the system call was made */
    state_PTR savedExceptionState = (state_PTR) BIOSDATAPAGE;
    LDST(savedExceptionState);
}


/*
 * Function     :   waitForIODevice
 * Purpose      :   Implement the SYS5 system call for waiting on an IO device.
 *                  First, calculate the index into the deviceSemaphores array. Decrement
 *                  the semaphore. If the value is negative, the process is blocked, its
 *                  CPU time is updated, and the scheduler is invoked. If the semaphore 
 *                  remains non-negative, resumes execution.
 * Parameters   :   lineNum - Interrupt line number for the device
 *                  deviceNum - Specific device number on that line
 *                  readBoolean - Boolean indicating if the device is waiting for a read (TRUE) or write (FALSE)
 */
void waitForIODevice(int lineNum, int deviceNum, int readBoolean) {
    /* Calculate the index in deviceSemaphores associated with the device requesting IO */
    int index;
    index = ((lineNum - OFFSET) * DEVPERINT) + deviceNum;
    
    /* If the device is terminal device and it is waiting for a write operation */
    if (lineNum == LINE7 && readBoolean == FALSE) {
        /* Increment the index, given that write semaphore is DEVPERINT (8) indices ahead */
        index += DEVPERINT;
    }

    /* Increment the soft block count */
    softBlockCount++;

    /* Decrement the semaphore by 1 (P operation) */
    (deviceSemaphores[index])--;   

    /* For synchronous IO, the semaphore should now be negative, indicating that the process must be blocked */
    if (deviceSemaphores[index] < 0) {
        /* Update the CPU usage time for the current process */
        STCK(currentTOD);
        currentProcess->p_time += (currentTOD - startTOD);

        /* Copy the saved processor state into current process's pcb */
        copyState((state_PTR) BIOSDATAPAGE, &(currentProcess->p_s));

        /* Block the current process on the device semaphore's ASL */
        insertBlocked(&(deviceSemaphores[index]), currentProcess);

        /* Clear currentProcess since it's blocked */
        currentProcess = NULL;

        /* Call the scheduler to dispatch the next process */
        scheduler();                /* This will never return */

        /* If the scheduler returns, something went wrong, be PANIC */
        PANIC();
    }

    /* If the semaphore does not go negative (unlikely for synchronous IO), 
       load the processor state at time SYSCALL was executed */
    LDST((state_PTR) BIOSDATAPAGE);
}


/*
 * Function     :   getCPUTime
 * Purpose      :   Implements the SYS6 system call to return the total CPU time used 
 *                  by the current process. Reads the current time-of-day and computes 
 *                  the difference from the last dispatch time. Adds this time difference 
 *                  to the process's accumulated CPU time. Returns the total CPU time via
 *                  register v0 and updates the process's PCB
 * Parameters   :   None
 */
void getCPUTime() {
    /* Obtain the saved processor state from the BIOS Data Page */
    state_PTR savedExceptionState;
    savedExceptionState = (state_PTR) BIOSDATAPAGE;

    /* Read the current Time-Of-Day into currentTOD */
    STCK(currentTOD);

    /* Update the lifetime CPU time in the current process's pcb */
    currentProcess->p_time += (currentTOD - startTOD);

    /* Place that total CPU time into v0 of the saved exception state */
    savedExceptionState->s_v0 = currentProcess->p_time;

    /* Restart the startTOD for the next time slice */
    STCK(startTOD);

    /* Load the processor state at time SYSCALL was executed */
    LDST(savedExceptionState);
}


/*
 * Function     :   waitForClock
 * Purpose      :   Implements the SYS7 system call to wait on the pseudo-clock.
 *                  Decrements the pseudo-clock semaphore (stored at the last index 
 *                  of deviceSemaphores). Saves the current processor state and 
 *                  updates CPU time. Blocks the current process on the pseudo-clock 
 *                  semaphore, increments softBlockCount, and invokes the scheduler
 * Parameters   :   None
 */
void waitForClock() {
    /* Obtain a pointer to the pseudo-clock semaphore */
    int *pclockSem = &deviceSemaphores[MAXDEVICES - 1];         /* Pseudo-clock semaphore is stored at last index */  

    /* Decrement the pseudo-clock semaphore */
    (*pclockSem)--;

    /* Update the accumulated CPU usage time for the current process */
    STCK(currentTOD);
    currentProcess->p_time += (currentTOD - startTOD);

    /* Copy the saved processor state into current process's pcb  */
    copyState((state_PTR) BIOSDATAPAGE, &(currentProcess->p_s));

    /* Insert the current process into the blocked queue */
    insertBlocked(pclockSem, currentProcess);

    /* Increment the softBlockCount */
    softBlockCount++;

    /* Clear the currentProcess (since it's blocked) */
    currentProcess = NULL;

    /* Call the scheduler to dispatch the next process */
    scheduler();                /* This should never return */

    /* If the scheduler() returns, something went wrong, be PANIC */
    PANIC();    
}


/*
 * Function     :   getSupportData
 * Purpose      :   Implements the SYS8 system call to return the support structure pointer
 *                  for the current process. Loads the support structure pointer into 
 *                  register v0 and resumes the process
 * Parameters   :   None
 */
void getSupportData() {
    /* Place the support structure pointer in v0 */
    currentProcess->p_s.s_v0 = (int)(currentProcess->p_supportStruct);

    /* Return control to the current process */
    LDST(&(currentProcess->p_s));
}


/*
 * Function     :   passUpOrDie
 * Purpose      :   Implements the "pass up or die" mechanism used by exception handlers.
 *                  If the current process has a support structure, the saved exception
 *                  state is copied into the appropriate field and then the exception is 
 *                  "passed up" via LDCXT to the user-level exception handler. If no 
 *                  support structure is present, the process is terminated (via SYS2), and 
 *                  the scheduler is called to dispatch another process
 * Parameters   :  exceptionCode - An index indicating which type of exception is being handled
 *
 * Behavior:
 *    - 
 *    - 
 *      
 */
void passUpOrDie(int exceptionCode) {
    /*--------------------------------------------------------------*
     * Pass Up Operation
     *--------------------------------------------------------------*/
    if (currentProcess->p_supportStruct != NULL) {
        /* Copy the saved exception state (from the BIOS Data Page) into the appropriate 
         * sup_exceptState field of the current process's support structure */
        state_PTR savedExceptionState;
        savedExceptionState = (state_PTR) BIOSDATAPAGE;
        copyState(savedExceptionState, &(currentProcess->p_supportStruct->sup_exceptState[exceptionCode]));
            
        /* Update the accumulated CPU time for the current process */
        STCK(currentTOD);
        currentProcess->p_time += (currentTOD - startTOD);

        /* Pass up the exception by performing a LDCXT using the context stored in 
         * the corresponding sup_exceptContext field (which includes the stack pointer,
         * status register, and program counter for the exception handler) */
        LDCXT(currentProcess->p_supportStruct->sup_exceptContext[exceptionCode].c_stackPtr,
            currentProcess->p_supportStruct->sup_exceptContext[exceptionCode].c_status,
            currentProcess->p_supportStruct->sup_exceptContext[exceptionCode].c_pc);
    }

    /*--------------------------------------------------------------*
     * Die Operation
     *--------------------------------------------------------------*/
    else {
        /* The current process has no support structure and cannot handle the exception
         * Handle the exception as fatal -> terminate the current process and all its progeny */
        terminateProcess(currentProcess);       /* Call SYS2 handler */
        currentProcess = NULL;                  /* Set the currentProcess pointer to NULL */
        scheduler();                            /* Call the scheduler to dispatch the next process */
    }
}


/*
 * Function     :   syscallExceptionHandler
 * Purpose      :   Handles system call exceptions by dispatching to the appropriate SYS call
 *                  handler based on the value in register a0. Retrieves the system call number 
 *                  from the saved processor state. Increments the program counter by one word 
 *                  (4 bytes) to avoid looping. Checks if the system call was invoked from 
 *                  user mode; if so, treats it as a program trap. Uses a switch statement to
 *                  dispatch to the specific system call handler (SYS1–SYS8).
 * Parameters   :   None
 */
void syscallExceptionHandler() {
    /* Retrieve the processor state at the time of exception */
    state_PTR savedExceptionState;
    savedExceptionState = (state_PTR) BIOSDATAPAGE;

    /* Retrieve the system call number from the saved state */
    unsigned int sysNum;                    /* Ensure that the SYSCALL number is non-negative */
    sysNum = savedExceptionState->s_a0;

    /* Increment the PC by WORDLEN (4) to avoid infinite SYSCALL loop */
    savedExceptionState->s_pc = savedExceptionState->s_pc + WORDLEN;
     
    /* Check if the SYSCALL was requested while in user-mode */
    if (((savedExceptionState->s_status) & USERPON) != ALLOFF) {
        /* Set the Cause */
        savedExceptionState->s_cause = (savedExceptionState->s_cause) & RESERVEDINSTRUCTION;
    
        /* Handle it as a Program Trap */
        programTrapExceptionHandler();
    }

    /* For SYSCALL exceptions numbered 9 and above, 
       call Pass Up or Die with GENERALEXCEPT handler */
    if ((sysNum > SYS8CALL)) {
        passUpOrDie(GENERALEXCEPT);
    }
    
    /* Dispatch the SYSCALL based on the syscall number in a0 */
    switch (sysNum) {
        /* SYS1: Create process */
        case SYS1CALL: 
            /* a1: Pointer to the initial state
               a2: Pointer to the support structure */
            createProcess((state_PTR) currentProcess->p_s.s_a1, (support_t *) currentProcess->p_s.s_a2);

        /* SYS2: Terminate process (and all its progeny )*/
        case SYS2CALL:
            /* Invoke the SYS2 handler */
            terminateProcess(currentProcess);

            /* Set the currentProcess pointer to NULL */
            currentProcess = NULL;

            /* Call the scheduler to dispatch the next process */
            scheduler();            /* This should never return */

            /* If the scheduler() returns, something went wrong, be PANIC */
            PANIC();            

        /* SYS3: P operator */
        case SYS3CALL:
            /* a1: Address of the semaphore to be P'ed */
            passeren((int *) currentProcess->p_s.s_a1);

        /* SYS4: V operator */    
        case SYS4CALL:
            /* a1: Address of the semaphore to be V'ed */
            verhogen((int *) currentProcess->p_s.s_a1);

        /* SYS5: Wait for IO Device */
        case SYS5CALL:
            /* a1: line number, a2: device number, a3: read/write indicator. */
            waitForIODevice(currentProcess->p_s.s_a1, currentProcess->p_s.s_a2, currentProcess->p_s.s_a3);

        /* SYS6: Get CPU time*/
        case SYS6CALL:
            getCPUTime();

        /* SYS7: Wait for clock */
        case SYS7CALL:
            waitForClock();

        /* SYS8: Get support data */
        case SYS8CALL:
            getSupportData();
    }
}


/*
 * Function     :   programTrapExceptionHandler
 * Purpose      :   The function handles the Program Trap Exception.
 *                  A program trap exception occurs when the current process attempts to perform
 *                  some illegal or undefined action. In such case, the handler will perform a
 *                  standard Pass Up Or Die operation using GENERALEXCEPT index value.
 * Parameters   :   None 
 */
void programTrapExceptionHandler() {
    passUpOrDie(GENERALEXCEPT);
} 


/*
 * Function     :   TLBExceptionHandler
 * Purpose      :   The function handles the TLB Exception.
 *                  A TLB exception occurs when uMPS3 fails in an attempt to translate a logical
 *                  address to a physical address. A TLB exception is defined as an exception
 *                  with Cause.ExcCodes of 1-3. In such case, the handler will perform a standard
 *                  Pass Up Or Die operation using PGFAULTEXCEPT index value.
 * Parameters   :   None 
 */
void TLBExceptionHandler() {
    passUpOrDie(PGFAULTEXCEPT);
}

/******************************* END OF EXCEPTIONS.c *******************************/
